<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Outbreak Epidemiology Disease Simulator</title>

  <style>
    /* Global design tokens: tune typography and weights here */
    :root {
      --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, Helvetica, Arial, sans-serif;
      --lh-base: 1.45;

      --fz-base: 12px;
      --fz-3xs: calc(var(--fz-base) * 0.571);
      --fz-2xs: calc(var(--fz-base) * 0.714);
      --fz-xs:  calc(var(--fz-base) * 0.857);
      --fz-sm:  calc(var(--fz-base) * 0.929);
      --fz-md:  calc(var(--fz-base) * 1.000);
      --fz-lg:  calc(var(--fz-base) * 1.143);
      --fz-xl:  calc(var(--fz-base) * 1.429);
      --fz-2xl: calc(var(--fz-base) * 1.714);
      --fz-3xl: calc(var(--fz-base) * 2.286);
      --fz-4xl: calc(var(--fz-base) * 2.857);

      --fw-regular: 400;
      --fw-medium: 500;
      --fw-semibold: 600;
      --fw-bold: 700;
    }

    /* Dark theme: editor-style palette and original simulation colors */
    :root[data-theme="dark"] {
      --bg: #1e1e1e;
      --panel: #252526;
      --panel-soft: #2d2d30;
      --canvas-bg: #272822;

      --text: #f8f8f2;
      --muted: #9da5b4;

      --accent: #66d9ef;
      --accent2: #fd971f;

      --c-sus: #525252;
      --c-exp: #ffd54a;
      --c-inf: #ff4d4d;
      --c-imm: #4cba87;
      --c-dead: #b00020;

      --vax-eff: #2196f3;
      --vax-ineff: #2196f3;

      --border-soft: rgba(255, 255, 255, 0.06);
      --border-strong: rgba(255, 255, 255, 0.18);
      --input-bg: #1e1e1e;
      --input-border: rgba(255, 255, 255, 0.14);

      --pill-bg: #2d2d30;

      --shadow-soft: 0 10px 30px rgba(0, 0, 0, 0.55);
    }

    /* Light theme: neutral surfaces with higher contrast */
    :root[data-theme="light"] {
      --bg: #fafafa;
      --panel: #ffffff;
      --panel-soft: #f5f5f5;
      --canvas-bg: #ffffff;

      --text: #111827;
      --muted: #8e908c;

      --accent: #22c5ff;
      --accent2: #ff9800;

      --c-sus: #d4d4d4;
      --c-exp: #fbbf24;
      --c-inf: #ef4444;
      --c-imm: #22c55e;
      --c-dead: #b91c1c;

      --vax-eff: #2563eb;
      --vax-ineff: #2563eb;

      --border-soft: rgba(0, 0, 0, 0.06);
      --border-strong: rgba(0, 0, 0, 0.16);
      --input-bg: #f9f9f9;
      --input-border: rgba(0, 0, 0, 0.16);

      --pill-bg: #f5f5f5;

      --shadow-soft: 0 6px 18px rgba(15, 23, 42, 0.12);
    }

    /* Theme toggle buttons share a consistent look per theme */
    :root[data-theme="light"] #themeToggle,
    :root[data-theme="light"] #toggleBtn {
      background: #e7e7e7;
      color: #272822;
      border-color: #d4d4d4;
    }

    :root[data-theme="dark"] #themeToggle,
    :root[data-theme="dark"] #toggleBtn {
      background: #3c3c3c;
      color: #f8f8f2;
      border-color: #454545;
    }

    /* Accessible theme: high contrast, colorblind-friendly palette */
    :root[data-theme="accessible"] {
      --bg: #ffffff;
      --panel: #ffffff;
      --panel-soft: #f2f2f2;
      --canvas-bg: #ffffff;

      --text: #111827;
      --muted: #4b5563;

      --accent: #0072b2;
      --accent2: #e69f00;

      --c-sus: #dddddd;
      --c-exp: #39deff;
      --c-inf: #e66000;
      --c-imm: #009e73;
      --c-dead: #3f2a56;

      --vax-eff: #56b4e9;
      --vax-ineff: #56b4e9;

      --border-soft: rgba(0, 0, 0, 0.14);
      --border-strong: rgba(0, 0, 0, 0.26);
      --input-bg: #f9fafb;
      --input-border: rgba(0, 0, 0, 0.26);

      --pill-bg: #f2f2f2;

      --shadow-soft: 0 6px 18px rgba(15, 23, 42, 0.16);

    }

    :root[data-theme="accessible"] #themeToggle,
    :root[data-theme="accessible"] #toggleBtn {
      background: #111827;
      color: #f9fafb;
      border-color: #0072b2;
    }

    /* Semantic text helpers mapped to simulation palette */
    .color-sus   { color: var(--c-sus); }
    .color-exp   { color: var(--c-exp); }
    .color-inf   { color: var(--c-inf); }
    .color-imm   { color: var(--c-imm); }
    .color-dead  { color: var(--c-dead); }

    .color-vax   { color: var(--accent); }
    .color-inc   { color: var(--c-exp); }
    .color-prev  { color: var(--accent2); }

    .swatch {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 3px;
      margin-right: 4px;
      vertical-align: middle;
    }
    .swatch-inc  { background: var(--c-exp); }
    .swatch-prev { background: var(--accent2); }
    .swatch-vax  { background: var(--accent); }
    .swatch-inf  { background: var(--c-inf); }
    .swatch-dead { background: var(--c-dead); }

    .metricRow-inc th,
    .metricRow-inc td.val {
      color: var(--c-exp);
    }
    .metricRow-prev th,
    .metricRow-prev td.val {
      color: var(--accent2);
    }

    .metricsTable td.formula {
      color: var(--muted);
      opacity: 0.9;
    }

    /* Theme selector in header */
    #themeSelect {
      padding: 6px 11px;
      border-radius: 999px;
      font-size: var(--fz-2xs);
      border: 1px solid var(--border-soft);
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      backdrop-filter: blur(6px);
      min-width: 130px;
    }

    :root[data-theme="light"] #themeSelect,
    :root[data-theme="accessible"] #themeSelect
     {
      background: #e7e7e7;
      color: #272822;
      border-color: #d4d4d4;
    }

    :root[data-theme="dark"] #themeSelect {
      background: #3c3c3c;
      color: #f8f8f2;
      border-color: #454545;
    }

    /* Layout and typography scaffold */
    * { box-sizing:border-box; }

    body {
      margin:0;
      font-family: var(--font-sans);
      font-size: var(--fz-base);
      line-height: var(--lh-base);
      background:var(--bg);
      color:var(--text);
      font-weight: var(--fw-regular);
    }

    header {
      position: static;
      top:0;
      z-index:20;
      background:linear-gradient(180deg,var(--panel) 0%,var(--bg) 100%);
    }

    .wrap {
      width:100%;
      margin:0;
      padding:16px;
    }

    header .wrap {
      position:static;
      padding-top:18px;
      padding-bottom:10px;
    }

    .header-bar {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
    }

    .header-text {
      max-width: 780px;
    }

    h1 {
      font-size: var(--fz-3xl);
      line-height:1.15;
      margin:0 0 8px;
      font-weight: var(--fw-bold);
      letter-spacing:0.01em;
    }

    @media (min-width:768px){
      h1 { font-size: var(--fz-4xl); }
    }

    .sub {
      color:var(--muted);
      max-width:780px;
      font-size: var(--fz-sm);
    }

    #simTimer {
      position:absolute;
      right:16px;
      bottom:14px;
    }

    .grid {
      display:grid;
      grid-template-columns:1fr;
      gap:14px;
    }

    .panel {
      background:var(--panel);
      border:1px solid var(--border-soft);
      border-radius:14px;
    }
    .pad { padding:12px; }

    .row {
      display:grid;
      grid-template-columns:repeat(12,1fr);
      gap:10px;
      align-items:end;
    }

    .cell { grid-column:span 3; }
    .cell.w2 { grid-column:span 2; }
    .cell.w4 { grid-column:span 4; }
    .cell.w6 { grid-column:span 6; }
    .cell.w12 { grid-column:span 12; }

    label {
      display:block;
      font-size: var(--fz-xs);
      color:var(--muted);
      margin:2px 0 6px;
    }

    input[type="number"],
    select {
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--input-border);
      background:var(--input-bg);
      color:var(--text);
      outline:none;
      font-size: var(--fz-md);
    }

    input[type="number"]:focus,
    select:focus {
      border-color:var(--accent);
      box-shadow:0 0 0 1px rgba(77,163,255,.24);
    }

    input[type="range"] { width:100%; }

    .popSlider { width:160px; max-width:100%; }

    .hint {
      font-size: var(--fz-xs);
      color:var(--muted);
      margin-left:6px;
    }

    .divider {
      border-top:1px solid var(--border-soft);
      margin:4px 0 4px;
    }

    .divider-label {
      font-size: var(--fz-3xs);
      text-transform:uppercase;
      letter-spacing:0.08em;
      color:var(--muted);
      margin-top:-2px;
    }

    .sim {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 260px;
      gap: 14px;
    }

    .sim > * { min-width: 0; }

    .canvasWrap { width: 100%; margin: 0; }

    canvas#sim {
      display: block;
      width: 100%;
      max-width: 1000px;
      margin: 0 auto;
      background: var(--canvas-bg);
      border-radius: 14px;
    }

    /* Left: live controls; right: simulation+sidebar or stacked on narrow viewports */
    .simLayout {
      display: grid;
      grid-template-columns: minmax(600px, 700px) minmax(0, 1fr);
      gap: 14px;
      margin-top: 12px;
    }

    @media (max-width: 1500px) {
      .simLayout { grid-template-columns: 1fr; }
    }

    .timelineTitle {
      font-size: var(--fz-xs);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-bottom: 4px;
    }

    /* Sidebar hosts the vertical status bar + legend + metrics anchors */
    .sidebar {
      position: relative;
      display: flex;
      flex-direction: column;
      height: 550px;
    }

    .status {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      padding: 12px;
    }

    .bar {
      position: relative;
      width: 42px;
      flex: 0 0 42px;
      height: 100%;
      border-radius: 10px;
      background: var(--canvas-bg);
      border: 1px solid var(--border-soft);
      overflow: hidden;
    }

    @media (max-width: 900px) {
      .sim {
        grid-template-columns: 1fr;
      }

      .sidebar {
        height: auto;
        max-height: none;
      }

      .status {
        flex: 0 0 auto;
      }

      .barsWrap {
        flex: 0 0 auto;
        align-items: flex-start;
      }

      .bar {
        height: 100%;
      }
    }

    .barsWrap {
      display: flex;
      gap: 10px;
      align-items: stretch;
      flex: 1 1 auto;
    }

    .seg { width:100%; }

    .legend {
      display: grid;
      grid-template-columns: 12px 1fr;
      gap: 4px 10px;
      margin-top: 0;
      width: auto;
      flex: 0 1 auto;
      min-width: 0;
      align-items: flex-start;
      align-content: flex-start;
    }

    .legend div {
      white-space: normal;
    }

    .legend .cnt {
      font-size: var(--fz-2xs);
      color:var(--muted);
      margin-left:4px;
    }

    .dot {
      width:12px;
      height:12px;
      border-radius:4px;
    }

    .vaxLegendIcon {
      width:14px;
      height:14px;
      border-radius:50%;
      box-sizing:border-box;
      border:2px solid var(--vax-eff);
      background:transparent;
    }
    .vaxLegendIcon.dotted { border-style:dashed; }

    .btn {
      appearance:none;
      border:none;
      border-radius:10px;
      background:var(--accent);
      color:#001027;
      padding:8px 12px;
      font-weight: var(--fw-bold);
      cursor:pointer;
      font-size: var(--fz-xs);
    }

    .btn.ghost {
      background:transparent;
      border:1px solid var(--border-strong);
      color:var(--text);
    }

    .btn:focus-visible,
    .miniBtn:focus-visible {
      outline:2px solid var(--accent);
      outline-offset:2px;
    }

    .footer {
      padding:10px 16px 16px;
      color:var(--muted);
      font-size: var(--fz-2xs);
      text-align:center;
      border-top:1px solid var(--border-soft);
      background:transparent;
    }

    .pill {
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:var(--pill-bg);
      border:1px solid var(--border-soft);
      padding:2px 10px;
      border-radius:999px;
      color:var(--muted);
      font-size: var(--fz-2xs);
    }

    .timePanel { margin-top:12px; }

    .scrubWrap {
      display:flex;
      align-items:center;
      gap:10px;
      margin:4px 0;
    }

    #scrubber { flex:1; }

    .miniBtn {
      appearance:none;
      border:1px solid var(--border-soft);
      background:var(--panel-soft);
      color:var(--text);
      border-radius:8px;
      padding:4px 8px;
      font-size: var(--fz-2xs);
      cursor:pointer;
    }

    .chartsPanel { margin-top:12px; }

    .chartsRow {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
      gap:10px;
    }

    .chartCell {
      position:relative;
      background:var(--canvas-bg);
      border-radius:12px;
      padding:8px;
      border:1px solid var(--border-soft);
    }

    .chartTitle {
      font-size: var(--fz-lg);
      color:var(--muted);
      margin:0 0 2px;
    }

    .chartExplain {
      font-size: var(--fz-xs);
      color:var(--muted);
      margin:0 0 4px;
      line-height:1.4;
    }

    canvas.chartCanvas {
      width:100%;
      height:auto;
      display:block;
      border-radius:8px;
    }

    .metricsPanel { margin-top: 12px; }

    .metricsTitle {
      font-size: var(--fz-lg);
      font-weight: var(--fw-semibold);
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 2px;
    }

    .metricsSub {
      font-size: var(--fz-xs);
      color: var(--muted);
      margin-bottom: 6px;
    }

    .metricsGrid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 8px;
    }

    .metricsBlock {
      background: var(--canvas-bg);
      border-radius: 10px;
      border: 1px solid var(--border-soft);
      padding: 6px;
    }

    .metricsBlockTitle {
      font-size: var(--fz-sm);
      font-weight: var(--fw-medium);
      color: var(--muted);
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .metricsTable {
      width: 100%;
      border-collapse: collapse;
      font-size: var(--fz-sm);
    }

    .metricsTable th,
    .metricsTable td {
      padding: 2px 2px;
      vertical-align: top;
    }

    .metricsTable th {
      text-align: left;
      font-weight: var(--fw-medium);
      color: var(--muted);
      width: 40%;
    }

    .metricsTable td.val {
      text-align: right;
      font-weight: var(--fw-semibold);
      width: 22%;
      white-space: nowrap;
    }

    .metricsTable td.formula {
      font-size: var(--fz-2xs);
      color: var(--muted);
    }

    .tag {
      display: inline-flex;
      padding: 1px 6px;
      border-radius: 999px;
      font-size: var(--fz-3xs);
      border: 1px solid var(--border-soft);
      color: var(--muted);
      gap: 4px;
      align-items: center;
    }

    .tag-inc {
      color: var(--c-exp);
      border-color: var(--c-exp);
    }

    .tag-prev {
      color: var(--accent2);
      border-color: var(--accent2);
    }
  </style>
</head>
<body>
<header>
  <div class="wrap header-bar">
    <div class="header-text">
      <h1>Outbreak Epidemiology Disease Simulator</h1>
      <div class="sub">
        Simulation of disease outbreaks using a toy SEIRD-style model with vaccination and waning immunity.
        Parameter sets are illustrative, not calibrated for policy decisions. Use as a learning sandbox to
        explore how changing transmission, duration, mortality, and vaccination assumptions alters dynamics.
      </div>
    </div>

    <div class="header-controls">
      <select id="themeSelect" aria-label="Select theme">
        <option value="light">Light</option>
        <option value="dark">Dark</option>
        <option value="accessible">Accessible</option>
      </select>
    </div>
  </div>
</header>

<main class="wrap grid" aria-live="polite">
  <section class="panel pad">
    <div class="divider-label timelineTitle">Startup Parameters</div>
    <div class="row" id="coreRow">
      <div class="cell">
        <label>Preset Scenario</label>
        <select id="scenario">
          <option value="custom">Custom</option>
          <option value="rare">Rare Disease</option>
          <option value="endemic">Endemic Stability</option>
          <option value="outbreak">Acute Outbreak</option>
          <option value="flu">Flu-like</option>
          <option value="covid">COVID-like</option>
          <option value="measles">Measles-like</option>
          <option value="ebola">Ebola-like</option>
          <option value="sars1">SARS-1-like</option>
          <option value="mers">MERS-like</option>
          <option value="noro">Norovirus-like</option>
        </select>
      </div>

      <div class="cell">
        <label>Population N (<span id="NVal">5000</span>)</label>
        <input
          id="N"
          class="popSlider"
          type="range"
          min="2"
          max="10000"
          step="1"
          value="5000"
        />
      </div>

      <div class="cell w2">
        <label>Contact Neighbors (4 or 6)</label>
        <select id="contacts">
          <option value="4" selected>4 · Square</option>
          <option value="6">6 · Hex</option>
        </select>
      </div>

      <div class="cell w2">
        <label>Seed</label>
        <input id="seed" type="number" value="42" />
      </div>

      <div class="cell w2">
        <label>Stochastic For Infection</label>
        <select id="stochastic">
          <option value="1">On</option>
          <option value="0">Off</option>
        </select>
      </div>

      <div class="cell w2">
        <label>Initial Infected</label>
        <input id="I0" type="number" min="0" max="10000" step="1" value="5" />
      </div>

      <div class="cell w2">
        <label>Initial Immune</label>
        <input id="R0" type="number" min="0" max="10000" step="1" value="0" />
      </div>

      <div class="cell w2">
        <label>
          Mutation / waning (immune → susceptible / day)
          <span class="hint" id="mutRateVal">0.000</span>
        </label>
        <input id="mutRate" type="range" min="0" max="0.5" step="0.005" value="0" />
      </div>

      <div class="cell w2">
        <label>
          Days Infectious
          <span class="hint" id="daysInfVal">10.0</span>
        </label>
        <input id="daysInf" type="range" min="1" max="30" step="0.5" value="10" />
      </div>

      <div class="cell w2">
        <label>Time step (days)</label>
        <input id="dt" type="number" min="0.1" max="10" step="0.1" value="1" />
      </div>

      <div class="cell w2">
        <label>Auto-stop when stable</label>
        <select id="autoStop">
          <option value="1">On</option>
          <option value="0">Off</option>
        </select>
      </div>
    </div>

    <div class="simLayout">
      <div class="panel pad">
        <div class="row">
          <div class="cell w12">
            <div class="divider-label timelineTitle">Live parameters</div>
          </div>

          <div class="cell w4">
            <label>Infection rate β <span class="hint" id="betaVal"></span></label>
            <input id="beta" type="range" min="0" max="1.2" step="0.01" value="0.35" />
          </div>
          <div class="cell w4">
            <label>Recovery rate γ <span class="hint" id="gammaVal"></span></label>
            <input id="gamma" type="range" min="0" max="1" step="0.01" value="0.1" />
          </div>
          <div class="cell w4">
            <label>Mortality rate μ <span class="hint" id="muVal"></span></label>
            <input id="mu" type="range" min="0" max="0.5" step="0.005" value="0.01" />
          </div>

          <div class="cell w4">
            <label>Vaccine / Medication Efficacy (%) <span class="hint" id="veVal"></span></label>
            <input id="ve" type="range" min="0" max="100" step="1" value="100" />
          </div>
          <div class="cell w4">
            <label>Vaccination Coverage (%) <span class="hint" id="vaxCovVal">0%</span></label>
            <input id="vaxCov" type="range" min="0" max="100" step="1" value="0" />
          </div>
          <div class="cell w4">
            <label>Daily Vaccination Rate (%-points/day) <span class="hint" id="vaxRateVal">0.0 pts/day</span></label>
            <input id="vaxRate" type="range" min="0" max="5" step="0.1" value="0" />
          </div>

          <div class="cell w6">
            <span class="hint">
              R₀ (theoretical)=<span id="R0disp">–</span>
            </span>
            <span class="hint">
              · R<sub>t</sub> (approx)=<span id="RtDisp">–</span>
            </span>
          </div>

          <div class="cell w12">
            <div class="timePanel">
              <div class="timelineTitle">Timeline</div>
              <div class="scrubWrap">
                <button class="btn" id="toggleBtn" aria-pressed="false">▶ Run</button>
                <button class="btn ghost" id="resetBtn">Reset</button>
                <span class="hint">t=<span id="timeDisp">0</span> days</span>
                <div class="hint">Viewing: <span id="viewLabel">Live</span></div>
              </div>
              <div class="scrubWrap">
                <span class="hint" id="scrubMin">0</span>
                <input type="range" id="scrubber" min="0" max="0" value="0" />
                <span class="hint" id="scrubVal">0</span>
                <span class="hint">/</span>
                <span class="hint" id="scrubMax">0</span>
                <span class="hint">days</span>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div class="sim">
        <div class="canvasWrap panel pad">
          <canvas id="sim" width="900" height="520" aria-label="Population grid"></canvas>
        </div>
        <aside class="sidebar panel">
          <div class="status">
            <div class="barsWrap">
              <div class="bar" aria-label="Status bar">
                <div class="seg" id="seg-imm"  style="background:var(--c-imm);height:0%"></div>
                <div class="seg" id="seg-exp"  style="background:var(--c-exp);height:0%"></div>
                <div class="seg" id="seg-inf"  style="background:var(--c-inf);height:0%"></div>
                <div class="seg" id="seg-sus"  style="background:var(--c-sus);height:100%"></div>
                <div class="seg" id="seg-dead" style="background:var(--c-dead);height:0%"></div>
              </div>

              <div class="legend">
                <div class="dot" style="background:var(--c-sus)"></div>
                <div>Susceptible <span id="pctS">100%</span> <span id="cntS" class="cnt">(0)</span></div>

                <div class="dot" style="background:var(--c-exp)"></div>
                <div>Exposed <span id="pctE">0%</span> <span id="cntE" class="cnt">(0)</span></div>

                <div class="dot" style="background:var(--c-inf)"></div>
                <div>Infectious <span id="pctI">0%</span> <span id="cntI" class="cnt">(0)</span></div>

                <div class="dot" style="background:var(--c-imm)"></div>
                <div>Immune <span id="pctR">0%</span> <span id="cntR" class="cnt">(0)</span></div>

                <div class="dot" style="background:var(--c-dead)"></div>
                <div>Dead <span id="pctD">0%</span> <span id="cntD" class="cnt">(0)</span></div>

                <div class="vaxLegendIcon"></div>
                <div>
                  Vaccinated &amp; protected
                  <span id="pctVeff">0%</span>
                  <span id="cntVeff" class="cnt">(0)</span>
                </div>

                <div class="vaxLegendIcon dotted"></div>
                <div>
                  Vaccinated, not effectively protected
                  <span id="pctVineff">0%</span>
                  <span id="cntVineff" class="cnt">(0)</span>
                </div>
              </div>
            </div>
          </div>
        </aside>

      </div>
    </div>

    <div class="panel pad chartsPanel">
      <div class="chartsRow">
        <div class="chartCell">
          <div class="chartTitle">Incidence, Prevalence &amp; % Vaccinated</div>
          <p class="chartExplain">
            <span style="color:var(--c-exp)">Incidence</span>: new infections per time step (S→E).
            <span style="color:var(--accent2)">Prevalence</span>: infectious individuals at each time.
            <span style="color:var(--accent)">Blue line</span>: percent of the population ever vaccinated.
          </p>
          <canvas
            id="incVaxChart"
            class="chartCanvas"
            aria-label="Incidence, prevalence, and percent vaccinated over time">
          </canvas>
        </div>
        <div class="chartCell">
          <div class="chartTitle">SEIRD Compartments</div>
          <p class="chartExplain">
            Tracks
            <span style="color:var(--c-sus)">susceptible</span>,
            <span style="color:var(--c-exp)">exposed</span>,
            <span style="color:var(--c-inf)">infectious</span>,
            <span style="color:var(--c-imm)">immune/recovered</span>,
            and <span style="color:var(--c-dead)">dead</span> over time.
          </p>
          <canvas
            id="sirChart"
            class="chartCanvas"
            aria-label="Susceptible, Exposed, Infectious, Immune, Dead over time">
          </canvas>
        </div>
      </div>
    </div>

    <div class="panel pad metricsPanel">
      <div class="metricsTitle">Epidemiologic Summary at Viewed Time</div>
      <div class="metricsSub">
        Uses tracked incident infections (S→E) for cumulative incidence, incidence rate, and CFR.
      </div>

      <div class="metricsGrid">
        <div class="metricsBlock">
          <div class="metricsBlockTitle">Context</div>
          <table class="metricsTable">
            <tbody>
              <tr>
                <th>Time (t)</th>
                <td id="m-t" class="val"></td>
                <td class="formula">Days since start</td>
              </tr>
              <tr>
                <th>Total population (N)</th>
                <td id="m-N" class="val"></td>
                <td class="formula">Initial individuals</td>
              </tr>
              <tr>
                <th>Alive at t</th>
                <td id="m-alive" class="val"></td>
                <td class="formula">N − deaths(t)</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="metricsBlock">
          <div class="metricsBlockTitle">
            <span class="tag tag-inc">
              Incidence &amp; Risk
            </span>
          </div>
          <table class="metricsTable">
            <tbody>
              <tr class="metricRow-inc">
                <th>
                  Cumulative incidence (risk)
                </th>
                <td id="m-cumInc" class="val"></td>
                <td class="formula">
                  Incident infections(0→t)
                  /
                  at-risk at start (N − I₀ − immune₀)
                </td>
              </tr>

              <tr class="metricRow-inc">
                <th>Incidence risk</th>
                <td id="m-incRisk" class="val"></td>
                <td class="formula">
                  Same as cumulative incidence over [0, t]
                </td>
              </tr>

              <tr class="metricRow-inc">
                <th>Average risk per day</th>
                <td id="m-riskRate" class="val"></td>
                <td class="formula">
                  Cumulative incidence / time interval
                </td>
              </tr>

              <tr class="metricRow-inc">
                <th>Incidence rate</th>
                <td id="m-incRate" class="val"></td>
                <td class="formula">
                  Incident infections(0→t)
                  /
                  person-time at risk
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="metricsBlock">
          <div class="metricsBlockTitle">
            <span class="tag tag-prev">
              Prevalence &amp; Severity
            </span>
          </div>
          <table class="metricsTable">
            <tbody>
              <tr class="metricRow-prev">
                <th>
                  Point prevalence (infectious)
                </th>
                <td id="m-prevPoint" class="val"></td>
                <td class="formula">
                  Infectious(t) / alive(t)
                </td>
              </tr>

              <tr>
                <th>
                  Ever infected (unique, simulated)
                </th>
                <td id="m-everInf" class="val color-inc"></td>
                <td class="formula">
                  Individuals with ≥1 S→E since start
                </td>
              </tr>

              <tr class="metricRow-severe">
                <th>
                  Case fatality risk
                </th>
                <td id="m-cfr" class="val color-dead"></td>
                <td class="formula">
                  Deaths(t) / ever infected (incident)
                </td>
              </tr>
            </tbody>
          </table>
        </div>

      </div>
    </div>

    <div class="panel pad" style="margin-top:12px">
      <button class="btn ghost" id="exportCSV">Export Time Series (CSV)</button>
    </div>
  </section>
</main>

<div class="footer">
  © <span id="year"></span> TapTiger Dev · MIT License · For teaching use only
</div>

<script>
'use strict';
(function(){
  /* Utility helpers kept local to avoid global leaks */
  function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
  const $ = sel => document.querySelector(sel);

  /* Theme bootstrap: reads persisted preference, then triggers a full repaint */
  const root = document.documentElement;
  const THEMES = ['dark', 'light', 'accessible'];
  const storedTheme = localStorage.getItem('sim-theme');
  const initialTheme = THEMES.includes(storedTheme) ? storedTheme : 'light';
  root.setAttribute('data-theme', initialTheme);

  const themeSelect = $('#themeSelect');

  function applyTheme(theme) {
    const next = THEMES.includes(theme) ? theme : 'light';
    root.setAttribute('data-theme', next);
    localStorage.setItem('sim-theme', next);

    // Theme affects all drawing colors, so redraw immediately
    drawCanvas();
    drawCharts();
    updateSidebarCounts();
    updateRDisplaysLive();
    updateMetrics();

    if (themeSelect && themeSelect.value !== next) {
      themeSelect.value = next;
    }
  }

  if (themeSelect) {
    themeSelect.value = initialTheme;
    themeSelect.addEventListener('change', (e) => {
      applyTheme(e.target.value);
    });
  }

  const yearEl = $('#year');
  if(yearEl){
    yearEl.textContent = new Date().getFullYear();
  }

  /* Pseudo-random generator override for reproducible runs using user-provided seed */
  function setSeed(s){
    let seed = (s>>>0) || 1;
    Math.random = function(){
      seed = (seed * 1664525 + 1013904223) >>> 0;
      return seed / 2**32;
    };
  }

  function cssVar(name){
    return getComputedStyle(document.documentElement)
      .getPropertyValue(name).trim();
  }

  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  /* State encoding for cell-level SEIRD status */
  const STATE = {
    S:0,
    E:1,
    I:2,
    R:3,
    D:4
  };

  /*
   * Central DOM handle map:
   * keep all querySelector calls in one place so wiring is easy to inspect.
   */
  const els = {
    scenario:$('#scenario'),
    N:$('#N'), I0:$('#I0'), R0:$('#R0'), dt:$('#dt'),
    beta:$('#beta'), gamma:$('#gamma'), mu:$('#mu'), ve:$('#ve'),
    betaVal:$('#betaVal'), gammaVal:$('#gammaVal'), muVal:$('#muVal'), veVal:$('#veVal'),
    vaxCov:$('#vaxCov'), vaxCovVal:$('#vaxCovVal'),
    vaxRate:$('#vaxRate'), vaxRateVal:$('#vaxRateVal'),
    mutRate:$('#mutRate'), mutRateVal:$('#mutRateVal'),
    daysInf:$('#daysInf'), daysInfVal:$('#daysInfVal'),
    stoch:$('#stochastic'), seed:$('#seed'),
    autoStop:$('#autoStop'),
    contacts:$('#contacts'),
    toggle:$('#toggleBtn'), reset:$('#resetBtn'),
    R0disp:$('#R0disp'), RtDisp:$('#RtDisp'), timeDisp:$('#timeDisp'),
    simCanvas:$('#sim'),
    segS:$('#seg-sus'), segE:$('#seg-exp'), segI:$('#seg-inf'),
    segR:$('#seg-imm'), segD:$('#seg-dead'),
    pctS:$('#pctS'), pctE:$('#pctE'), pctI:$('#pctI'), pctR:$('#pctR'), pctD:$('#pctD'),
    cntS:$('#cntS'), cntE:$('#cntE'), cntI:$('#cntI'), cntR:$('#cntR'), cntD:$('#cntD'),
    pctVeff:$('#pctVeff'), pctVineff:$('#pctVineff'),
    cntVeff:$('#cntVeff'), cntVineff:$('#cntVineff'),
    exportCSV:$('#exportCSV'),
    scrubber:$('#scrubber'), viewLabel:$('#viewLabel'),
    scrubMin:$('#scrubMin'),
    scrubVal:$('#scrubVal'),
    scrubMax:$('#scrubMax'),
    NVal:$('#NVal'),
    incVaxChart:$('#incVaxChart'),
    sirChart:$('#sirChart'),
    m_t: $('#m-t'),
    m_N: $('#m-N'),
    m_alive: $('#m-alive'),
    m_cumInc: $('#m-cumInc'),
    m_incRisk: $('#m-incRisk'),
    m_riskRate: $('#m-riskRate'),
    m_incRate: $('#m-incRate'),
    m_prevPoint: $('#m-prevPoint'),
    m_everInf: $('#m-everInf'),
    m_cfr: $('#m-cfr')
  };

  /*
   * Simulation master state:
   * - Holds parameters, grid, time series, snapshots, and run status.
   * - All derived views (charts, metrics, legend) read from this object.
   */
  const State = {
    N:5000,
    dt:1,
    beta:0.35,
    gamma:0.1,
    mu:0.01,
    ve:0,
    I0:5,
    R0init:0,
    vaxRate:0,
    mutRate:0,

    t:0,
    running:false,

    people:[],
    cols:0,
    rows:0,

    series:{
      t:[], S:[], E:[], I:[], R:[], D:[],
      inc:[], prev:[], cumInc:[],
      vAllPct:[], vEffPct:[],
      everInf:[]
    },

    snapshots:[],
    viewIndex:null,
    stableCounter:0,

    // Count of unique individuals ever infected via S→E; drives CI/CFR outputs.
    everInfectedCount:0
  };

  /* Snapshot helper: provides the "viewed" grid when scrubbing through history */
  function getViewSnapshot(){
    const idx = State.viewIndex;
    if (idx != null && State.snapshots[idx]) {
      return State.snapshots[idx];
    }
    return null;
  }

  /*
   * Aggregate current compartment sizes for either:
   * - selected snapshot (scrubber position), or
   * - live state (when not scrubbing).
   */
  function computeAggregatesFromCurrentView(){
    const snap = getViewSnapshot();
    const src = snap || State.people;
    const N = src.length || 1;

    let S=0,E=0,I=0,R=0,D=0;
    let vEff=0,vIneff=0;

    for(const p of src){
      const s = p.state;
      if(s===STATE.S) S++;
      else if(s===STATE.E) E++;
      else if(s===STATE.I) I++;
      else if(s===STATE.R) R++;
      else if(s===STATE.D) D++;

      if(p.v){
        if(p.vEff) vEff++;
        else vIneff++;
      }
    }

    return {N,S,E,I,R,D,vEff,vIneff};
  }

  /* Push aggregate values into sidebar stacked bar + legend counts */
  function updateSidebarFromAggregates(agg){
    const { N, S, E, I, R, D, vEff, vIneff } = agg;
    const pct = x => 100 * x / Math.max(1, N);

    const pS=pct(S), pE=pct(E), pI=pct(I), pR=pct(R), pD=pct(D);
    const total=(pS+pE+pI+pR+pD) || 1;
    const k=100/total;

    const hS=pS*k, hE=pE*k, hI=pI*k, hR=pR*k, hD=pD*k;

    els.segS.style.height=hS+"%";
    els.segE.style.height=hE+"%";
    els.segI.style.height=hI+"%";
    els.segR.style.height=hR+"%";
    els.segD.style.height=hD+"%";

    els.pctS.textContent=hS.toFixed(0)+"%";
    els.pctE.textContent=hE.toFixed(0)+"%";
    els.pctI.textContent=hI.toFixed(0)+"%";
    els.pctR.textContent=hR.toFixed(0)+"%";
    els.pctD.textContent=hD.toFixed(0)+"%";

    els.cntS.textContent=`(${S})`;
    els.cntE.textContent=`(${E})`;
    els.cntI.textContent=`(${I})`;
    els.cntR.textContent=`(${R})`;
    els.cntD.textContent=`(${D})`;

    const pctEff   = pct(vEff);
    const pctInef  = pct(vIneff);

    if(els.pctVeff)   els.pctVeff.textContent   = pctEff.toFixed(0)+"%";
    if(els.cntVeff)   els.cntVeff.textContent   = `(${vEff})`;
    if(els.pctVineff) els.pctVineff.textContent = pctInef.toFixed(0)+"%";
    if(els.cntVineff) els.cntVineff.textContent = `(${vIneff})`;
  }

  function updateSidebarCounts(){
    const agg = computeAggregatesFromCurrentView();
    updateSidebarFromAggregates(agg);
  }

  /* Vaccination coverage calculations for UI sync */
  function computeVaxStats(){
    const N = State.people.length || 1;
    let vAll = 0;
    for(const p of State.people){
      if(p.v) vAll++;
    }
    return {
      vAll,
      vAllPct: 100 * vAll / Math.max(1, N)
    };
  }

  function syncVaxCovSliderToState(){
    if(!els.vaxCov) return;
    const { vAllPct } = computeVaxStats();
    const val = clamp(vAllPct, 0, 100);
    els.vaxCov.value = val.toFixed(0);
    if(els.vaxCovVal){
      els.vaxCovVal.textContent = val.toFixed(0) + "%";
    }
  }

  /*
   * Metrics table renderer:
   * - Uses time-series plus unique ever-infected count.
   * - Reads either the live tail or currently scrubbed index.
   */
  function updateMetrics(){
    const s = State.series;
    const len = s.t.length;

    const idx = (State.viewIndex != null)
      ? Math.min(State.viewIndex, Math.max(0, len - 1))
      : Math.max(0, len - 1);

    if(len === 0 || idx < 0){
      setMetricsDash();
      return;
    }

    const t = s.t[idx];
    const S = s.S[idx];
    const E = s.E[idx];
    const I = s.I[idx];
    const R = s.R[idx];
    const D = s.D[idx];

    const N = State.N || (S + E + I + R + D) || 1;
    const atRisk0 = Math.max(1, N - (State.I0 || 0) - (State.R0init || 0));

    const everInfected = (s.everInf && s.everInf[idx] != null)
      ? s.everInf[idx]
      : (State.everInfectedCount || 0);

    const cumIncRisk = atRisk0 > 0 ? (everInfected / atRisk0) : NaN;
    const incRisk = cumIncRisk;
    const riskRate = (t > 0 && atRisk0 > 0) ? (cumIncRisk / t) : NaN;

    let ptAtRisk = 0;
    for(let j = 0; j <= idx; j++){
      const Sj = s.S[j] ?? S;
      const dt = (j === 0)
        ? (s.t[0] || State.dt || 1)
        : ((s.t[j] - s.t[j-1]) || State.dt || 1);
      ptAtRisk += Sj * dt;
    }
    const incRate = ptAtRisk > 0 ? (everInfected / ptAtRisk) : NaN;

    const alive = Math.max(1, N - D);
    const prevPoint = I / alive;
    const cfr = everInfected > 0 ? (D / everInfected) : NaN;

    const fmtPct = x =>
      (!isFinite(x) ? '–' : (x * 100).toFixed(1) + '%');

    const fmtRate = (x, unit) =>
      (!isFinite(x) ? '–' : x.toFixed(4) + ' ' + unit);

    const fmtCount = x =>
      (!isFinite(x) ? '–' : Math.round(x).toString());

    const fmtTime = x =>
      (!isFinite(x) ? '–' : x.toFixed(1) + ' d');

    if(els.m_t)          els.m_t.textContent          = fmtTime(t);
    if(els.m_N)          els.m_N.textContent          = fmtCount(N);
    if(els.m_alive)      els.m_alive.textContent      = fmtCount(alive);

    if(els.m_cumInc)     els.m_cumInc.textContent     = fmtPct(cumIncRisk);
    if(els.m_incRisk)    els.m_incRisk.textContent    = fmtPct(incRisk);
    if(els.m_riskRate)   els.m_riskRate.textContent   = fmtRate(riskRate, '/day');
    if(els.m_incRate)    els.m_incRate.textContent    = fmtRate(incRate, 'per person-day');

    if(els.m_prevPoint)  els.m_prevPoint.textContent  = fmtPct(prevPoint);
    if(els.m_everInf)    els.m_everInf.textContent    = fmtCount(everInfected);
    if(els.m_cfr)        els.m_cfr.textContent        = fmtPct(cfr);
  }

  function setMetricsDash(){
    const ids = [
      'm-t','m-N','m-alive',
      'm-cumInc','m-incRisk','m-riskRate','m-incRate',
      'm-prevPoint','m-everInf','m-cfr'
    ];
    ids.forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.textContent = '–';
    });
  }

  /* R0/Rt display: quick teaching aids derived from β, γ, and current S(t) */
  function computeR0(){
    const beta=+els.beta.value, gamma=+els.gamma.value;
    return gamma>0? (beta/gamma):Infinity;
  }

  function updateRDisplaysLive(){
    if(!els.R0disp || !els.RtDisp) return;

    const R0 = computeR0();
    els.R0disp.textContent = Number.isFinite(R0) ? R0.toFixed(2) : '∞';

    const agg = computeAggregatesFromCurrentView();
    const N = agg.N || State.N || 1;
    const effectivePop = Math.max(1, N - agg.D);
    const Rt = R0 * (agg.S / effectivePop);

    els.RtDisp.textContent = Number.isFinite(Rt) ? Rt.toFixed(2) : '∞';
  }

  /* Keep all slider labels, derived parameters, and metrics visually in sync */
  function syncSliders(){
    if(els.betaVal)  els.betaVal.textContent  = Number(els.beta.value).toFixed(2);
    if(els.gammaVal) els.gammaVal.textContent = Number(els.gamma.value).toFixed(2);
    if(els.muVal)    els.muVal.textContent    = Number(els.mu.value).toFixed(3);
    if(els.veVal)    els.veVal.textContent    = Number(els.ve.value).toFixed(0) + "%";

    if(els.vaxCov && els.vaxCovVal){
      els.vaxCovVal.textContent = Number(els.vaxCov.value).toFixed(0) + "%";
    }
    if(els.vaxRate && els.vaxRateVal){
      els.vaxRateVal.textContent =
        Number(els.vaxRate.value).toFixed(1) + " pts/day";
    }
    if(els.mutRate && els.mutRateVal){
      els.mutRateVal.textContent =
        Number(els.mutRate.value).toFixed(3);
    }
    if(els.daysInf && els.daysInfVal){
      els.daysInfVal.textContent =
        Number(els.daysInf.value).toFixed(1);
    }
    if(els.NVal && els.N){
      els.NVal.textContent = els.N.value;
    }

    updateRDisplaysLive();
    updateMetrics();
  }

  function setToggleRunning(){
    State.running = true;
    els.toggle.textContent = '⏸ Pause';
    els.toggle.setAttribute('aria-pressed','true');
  }

  function resetToggleToStopped(){
    State.running = false;
    els.toggle.textContent = '▶ Run';
    els.toggle.setAttribute('aria-pressed','false');
  }

  /* Allows user-friendly "days infectious" slider; internally updates γ */
  function applyDaysInfToGamma(){
    if(!els.daysInf || !els.gamma) return;
    const days = +els.daysInf.value || 10;
    const g = days > 0 ? (1 / days) : (+els.gamma.value || 0.1);
    els.gamma.value = g.toFixed(2);
  }

  /* Chart canvas sizing: responsive + HiDPI aware */
  function prepareChartCanvas(c){
    if (!c || !c.parentElement) return;
    const parent = c.parentElement;
    const dpr = window.devicePixelRatio || 1;

    let cssWidth = parent.clientWidth * 0.94;
    if (cssWidth <= 0) cssWidth = 400;

    let cssHeight = Math.max(130, Math.round(cssWidth * 0.35));

    c.style.width = cssWidth + "px";
    c.style.height = cssHeight + "px";

    const displayWidth = Math.floor(cssWidth * dpr);
    const displayHeight = Math.floor(cssHeight * dpr);

    if (c.width !== displayWidth || c.height !== displayHeight) {
      c.width = displayWidth;
      c.height = displayHeight;
    }

    const ctx = c.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function updateChartLayouts(){
    prepareChartCanvas(els.incVaxChart);
    prepareChartCanvas(els.sirChart);
  }

  /* Simulation canvas sizing mirrors chart strategy for a fixed aspect ratio */
  function resizeSimCanvas() {
    const c = els.simCanvas;
    if (!c) return;

    const wrapper = c.parentElement;
    if (!wrapper) return;

    const dpr = window.devicePixelRatio || 1;
    const styles = getComputedStyle(wrapper);
    const paddingX =
      parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);

    const availableOuter = wrapper.getBoundingClientRect().width || 900;
    const cssWidth = Math.min(availableOuter - paddingX, 900);
    const aspect = 520 / 900;
    const cssHeight = cssWidth * aspect;

    c.style.width = cssWidth + 'px';
    c.style.height = cssHeight + 'px';

    const w = Math.floor(cssWidth * dpr);
    const h = Math.floor(cssHeight * dpr);

    if (c.width !== w || c.height !== h) {
      c.width = w;
      c.height = h;
    }

    const ctx = c.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  /*
   * initPeople:
   * - Builds grid layout based on N
   * - Applies initial immune/infected
   * - Allocates time series and snapshots
   * - Applies initial vaccination and redraws everything
   */
  function initPeople(){
    applyDaysInfToGamma();
    syncSliders();

    const N = clamp(+els.N.value || 5000, 2, 10000);
    const I0 = clamp(+els.I0.value || 5, 0, N);
    const R0init = clamp(+els.R0.value || 0, 0, N - I0);

    const cols = Math.ceil(Math.sqrt(N)*1.3);
    const rows = Math.ceil(N / cols);

    State.cols = cols;
    State.rows = rows;

    State.people = new Array(N).fill(0).map((_,i)=>({
      col:i%cols,
      row:Math.floor(i/cols),
      state:STATE.S,
      v:0,
      vEff:0,
      everInf:0
    }));

    const idxs = shuffle([...Array(N).keys()]);

    for(let i=0;i<R0init && i<idxs.length;i++){
      State.people[idxs[i]].state = STATE.R;
    }

    let used = R0init;
    let assignedI = 0;
    while(assignedI < I0 && used < idxs.length){
      const p = State.people[idxs[used]];
      if(p.state === STATE.S){
        p.state = STATE.I;
        assignedI++;
      }
      used++;
    }

    State.N = N;
    State.I0 = I0;
    State.R0init = R0init;
    State.t = 0;

    State.series = {
      t:[], S:[], E:[], I:[], R:[], D:[],
      inc:[], prev:[], cumInc:[],
      vAllPct:[], vEffPct:[],
      everInf:[]
    };
    State.snapshots = [];
    State.viewIndex = null;
    State.stableCounter = 0;
    State.everInfectedCount = 0;

    assignVaccinationInitial();
    syncVaxCovSliderToState();

    resetToggleToStopped();
    els.timeDisp.textContent='0';
    els.viewLabel.textContent='Live';
    refreshScrubber();
    resizeSimCanvas();
    drawCanvas();
    updateSidebarCounts();
    drawCharts();
    updateRDisplaysLive();
    updateMetrics();
  }

  /* Initial vaccination assignment for startup or scenario changes */
  function assignVaccinationInitial(){
    const cov = (+els.vaxCov.value||0)/100;
    const ve = (+els.ve.value||0)/100;
    const N = State.people.length;
    const k = Math.round(N*cov);

    State.people.forEach(p=>{ p.v=0; p.vEff=0; });

    const idxs = shuffle([...State.people.keys()]);
    for(let i=0;i<k && i<idxs.length;i++){
      const p = State.people[idxs[i]];
      p.v = 1;
      p.vEff = (Math.random() < ve) ? 1 : 0;
    }
  }

  /*
   * branchFromCurrent:
   * - Used when user scrubs to a past time and changes parameters.
   * - Rebuilds live state from chosen snapshot and optionally reassigns vaccination.
   */
  function branchFromCurrent({reassignVaccination}){
    const len = State.series.t.length;
    const haveHistory = len>0 && State.snapshots.length>=len;

    if(!haveHistory){
      if(reassignVaccination){
        assignVaccinationInitial();
        syncVaxCovSliderToState();
        drawCanvas();
        updateSidebarCounts();
        drawCharts();
        updateRDisplaysLive();
        updateMetrics();
      }
      return;
    }

    const idx = (State.viewIndex!=null)
      ? clamp(State.viewIndex, 0, len-1)
      : (len-1);

    const snap = State.snapshots[idx];
    if(!snap) return;

    State.people.forEach((p,i)=>{
      const s = snap[i];
      if(!s) return;
      p.state = s.state;
      p.v = s.v;
      p.vEff = s.vEff;
      p.everInf = s.everInf || 0;
    });

    if(reassignVaccination){
      const cov = (+els.vaxCov.value||0)/100;
      const ve = (+els.ve.value||0)/100;
      const N = State.people.length;
      const k = Math.round(N*cov);

      State.people.forEach(p=>{ p.v=0; p.vEff=0; });
      const idxs2 = shuffle([...State.people.keys()]);
      for(let j=0;j<k && j<idxs2.length;j++){
        const p = State.people[idxs2[j]];
        p.v = 1;
        p.vEff = (Math.random() < ve) ? 1 : 0;
      }
    }

    Object.keys(State.series).forEach(key=>{
      State.series[key] = State.series[key].slice(0, idx+1);
    });
    State.snapshots = State.snapshots.slice(0, idx+1);

    State.t = State.series.t[idx] || 0;
    State.viewIndex = null;
    State.stableCounter = 0;
    State.everInfectedCount =
      (State.series.everInf && State.series.everInf[idx] != null)
        ? State.series.everInf[idx]
        : 0;

    syncVaxCovSliderToState();
    els.viewLabel.textContent = `t=${State.t.toFixed(0)} days`;
    refreshScrubber();
    drawCanvas();
    updateSidebarCounts();
    drawCharts();
    updateRDisplaysLive();
    updateMetrics();
  }

  /*
   * Neighborhood logic:
   * - 4-neighbor: von Neumann (grid)
   * - 6-neighbor: offset hex approximation using row parity.
   */
  function infectiousNeighborCount(p, infSet, contact){
    const col = p.col;
    const row = p.row;

    if(contact === '4'){
      const coords = [
        [col+1,row],[col-1,row],
        [col,row+1],[col,row-1]
      ];
      let k=0;
      for(const [c,r] of coords){
        if(infSet.has(c + "," + r)) k++;
      }
      return k;
    }

    const isOdd = (row % 2) === 1;
    let coords;
    if(!isOdd){
      coords = [
        [col-1,row],[col+1,row],
        [col,row-1],[col-1,row-1],
        [col,row+1],[col-1,row+1]
      ];
    }else{
      coords = [
        [col-1,row],[col+1,row],
        [col+1,row-1],[col,row-1],
        [col+1,row+1],[col,row+1]
      ];
    }
    let k=0;
    for(const [c,r] of coords){
      if(infSet.has(c + "," + r)) k++;
    }
    return k;
  }

  /*
   * Core update step:
   * - Applies SEIRD transitions per cell.
   * - Applies vaccination flow and waning.
   * - Records time series + snapshot for scrubbing.
   */
  function step(){
    const beta    = +els.beta.value;
    const gamma   = +els.gamma.value;
    const mu      = +els.mu.value;
    const dt      = +els.dt.value;
    const N       = State.people.length;
    const contact = els.contacts.value || '4';

    const vaxRate = els.vaxRate ? (+els.vaxRate.value || 0) : 0;
    const mutRate = els.mutRate ? (+els.mutRate.value || 0) : 0;
    const veFrac  = (+els.ve.value || 0)/100;

    if(!N) return;

    const curStates = State.people.map(p=>p.state);
    const infSet = new Set();
    State.people.forEach((p,i)=>{
      if(curStates[i]===STATE.I){
        infSet.add(p.col + "," + p.row);
      }
    });

    const newStates = curStates.slice();
    let newI = 0;
    let newIncidents = 0;

    for(let i=0;i<N;i++){
      const p = State.people[i];
      const s = curStates[i];

      if(s===STATE.S){
        if(p.v && p.vEff) continue;
        const kInf = infectiousNeighborCount(p, infSet, contact);
        if(kInf>0){
          const prob = 1 - Math.exp(-beta * kInf * dt);
          if(els.stoch.value==="1"){
            if(Math.random() < prob){
              newStates[i] = STATE.E;
              if(p.everInf === 0){
                p.everInf = 1;
                newIncidents++;
              }
            }
          }else{
            if(prob > 0.01){
              newStates[i] = STATE.E;
              if(p.everInf === 0){
                p.everInf = 1;
                newIncidents++;
              }
            }
          }
        }
      }
      else if(s===STATE.E){
        if(Math.random() < 0.5*dt){
          newStates[i] = STATE.I;
          newI++;
        }
      }
      else if(s===STATE.I){
        const pr = 1 - Math.exp(-gamma*dt);
        const pm = 1 - Math.exp(-mu*dt);
        const u  = Math.random();
        if(u < pm){
          newStates[i] = STATE.D;
        }else if(u < pm + pr){
          newStates[i] = STATE.R;
        }
      }
    }

    State.everInfectedCount += newIncidents;

    if(mutRate > 0){
      const pMut = 1 - Math.exp(-mutRate * dt);
      for(let i=0;i<N;i++){
        const st = newStates[i];
        const person = State.people[i];
        const isImmune = (st === STATE.R);
        const isEffVax = (person.v && person.vEff);
        if(isImmune || isEffVax){
          if(Math.random() < pMut){
            newStates[i] = STATE.S;
            person.v = 0;
            person.vEff = 0;
          }
        }
      }
    }

    for(let i=0;i<N;i++){
      State.people[i].state = newStates[i];
    }

    if(vaxRate > 0){
      const stepPoints = vaxRate * dt;
      let targetNew = Math.round((stepPoints/100) * N);
      if(targetNew > 0){
        const candidates = [];
        for(let i=0;i<N;i++){
          const p = State.people[i];
          if(p.state !== STATE.D && !p.v){
            candidates.push(i);
          }
        }
        if(targetNew > candidates.length) targetNew = candidates.length;

        for(let i=candidates.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [candidates[i],candidates[j]] = [candidates[j],candidates[i]];
        }

        for(let k=0;k<targetNew;k++){
          const idx = candidates[k];
          const p   = State.people[idx];
          p.v = 1;
          p.vEff = (Math.random() < veFrac) ? 1 : 0;
        }
      }
    }

    let S=0,E=0,I=0,R=0,D=0;
    let vAll=0, vEff=0;
    for(const p of State.people){
      if(p.state===STATE.S) S++;
      else if(p.state===STATE.E) E++;
      else if(p.state===STATE.I) I++;
      else if(p.state===STATE.R) R++;
      else if(p.state===STATE.D) D++;

      if(p.v){
        vAll++;
        if(p.vEff) vEff++;
      }
    }

    const prevT = State.series.t.at(-1) || 0;
    const tNext = prevT + dt;

    const vAllPct = 100 * vAll / Math.max(1,N);
    const vEffPct = 100 * vEff / Math.max(1,N);

    const atRisk0 = Math.max(1, State.N - State.I0 - State.R0init);
    const cumInc = atRisk0 > 0
      ? (State.everInfectedCount / atRisk0)
      : 0;

    State.series.t.push(tNext);
    State.series.S.push(S);
    State.series.E.push(E);
    State.series.I.push(I);
    State.series.R.push(R);
    State.series.D.push(D);
    State.series.inc.push(Math.max(0,newI));
    State.series.prev.push(I/Math.max(1,N));
    State.series.cumInc.push(cumInc);
    State.series.vAllPct.push(vAllPct);
    State.series.vEffPct.push(vEffPct);
    State.series.everInf.push(State.everInfectedCount);

    State.snapshots.push(
      State.people.map(p => ({
        state:p.state,
        v:p.v,
        vEff:p.vEff,
        everInf:p.everInf
      }))
    );

    syncVaxCovSliderToState();
    updateHeaderStats(tNext);
    refreshScrubber();
    drawCanvas();
    updateSidebarCounts();
    drawCharts();
    updateMetrics();

    const stableNow = (I === 0 && E === 0);
    State.stableCounter = stableNow ? State.stableCounter + 1 : 0;

    if(els.autoStop.value==='1' && State.stableCounter>=10){
      State.running=false;
      resetToggleToStopped();
      const timerEl = $('#simTimer');
      if(timerEl){
        timerEl.textContent = `t=${tNext.toFixed(0)} days · paused (stable)`;
      }
    }
  }

  function updateHeaderStats(t){
    els.timeDisp.textContent = t.toFixed(0);
    const timerEl = $('#simTimer');
    if(timerEl){
      timerEl.textContent = `t=${t.toFixed(0)} days`;
    }
    updateRDisplaysLive();
    updateMetrics();
  }

  /*
   * drawCanvas:
   * - Visualizes individuals as dots in either grid or hex layout.
   * - Respects scrubbed snapshot when viewing history.
   */
  function drawCanvas(){
    const c = els.simCanvas;
    if (!c) return;
    const ctx = c.getContext('2d');
    const dpr = window.devicePixelRatio || 1;

    const W = (c.clientWidth || c.width / dpr);
    const H = (c.clientHeight || c.height / dpr);

    ctx.clearRect(0,0,W,H);
    ctx.fillStyle=cssVar('--canvas-bg') || '#0e1320';
    ctx.fillRect(0,0,W,H);

    const N=State.people.length;
    if(!N) return;

    const cols = State.cols || Math.ceil(Math.sqrt(N));
    const rows = State.rows || Math.ceil(N/cols);
    const contact = els.contacts.value || '4';

    const idx = State.viewIndex;
    const snapshot = (idx!=null && State.snapshots[idx])
      ? State.snapshots[idx]
      : null;

    if(contact === '4'){
      const cell = Math.min(W/cols, H/rows);
      const offsetX = (W - cols*cell)/2;
      const offsetY = (H - rows*cell)/2;

      State.people.forEach((p,i)=>{
        const sObj = snapshot ? snapshot[i] : p;
        const state = sObj.state;
        const v     = sObj.v;
        const vEff  = sObj.vEff;

        const x = offsetX + (p.col + 0.5)*cell;
        const y = offsetY + (p.row + 0.5)*cell;
        const r = Math.max(2, cell*0.30);

        ctx.fillStyle=getColor(state);
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();

        if(v){
          ctx.strokeStyle = cssVar('--vax-eff');
          ctx.lineWidth = 1;
          if(vEff){ ctx.setLineDash([]); }
          else{ ctx.setLineDash([3,3]); }
          ctx.beginPath();
          ctx.arc(x,y,r+2,0,Math.PI*2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      });
    } else {
      const colsHex = cols;
      const rowsHex = rows;
      const baseWUnits = 2 + 1.5*(colsHex - 1) + 0.75;
      const baseHUnits = 2 + (rowsHex - 1)*Math.sqrt(3);
      const r = Math.max(2, Math.min(W/baseWUnits, H/baseHUnits));
      const w = 1.5 * r;
      const h = Math.sqrt(3) * r;

      const totalW = 2*r + (colsHex - 1)*w + 0.5*w;
      const totalH = 2*r + (rowsHex - 1)*h;
      const offsetX = (W - totalW)/2;
      const offsetY = (H - totalH)/2;

      State.people.forEach((p,i)=>{
        const sObj = snapshot ? snapshot[i] : p;
        const state = sObj.state;
        const v     = sObj.v;
        const vEff  = sObj.vEff;

        const row = p.row;
        const col = p.col;

        const x = offsetX + r + col*w + (row%2 ? w/2 : 0);
        const y = offsetY + r + row*h;
        const rr = r*0.5;

        ctx.fillStyle = getColor(state);
        ctx.beginPath();
        ctx.arc(x,y,rr,0,Math.PI*2);
        ctx.fill();

        if(v){
          ctx.strokeStyle = cssVar('--vax-eff');
          ctx.lineWidth = 1;
          if(vEff){ ctx.setLineDash([]); }
          else{ ctx.setLineDash([3,3]); }
          ctx.beginPath();
          ctx.arc(x,y,rr+2,0,Math.PI*2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      });
    }
  }

  function getColor(state){
    if(state===STATE.S) return cssVar('--c-sus');
    if(state===STATE.E) return cssVar('--c-exp');
    if(state===STATE.I) return cssVar('--c-inf');
    if(state===STATE.R) return cssVar('--c-imm');
    return cssVar('--c-dead');
  }

  /*
   * Scrubber:
   * - Maps indices onto the recorded time series.
   * - When viewIndex is null, charts and canvas show live tail.
   */
  function refreshScrubber(){
    const len = State.series.t.length;
    const maxIndex = Math.max(0, len-1);
    els.scrubber.max = String(maxIndex);

    if(State.viewIndex==null){
      els.scrubber.value = String(maxIndex);
    }

    const lastT = len ? (State.series.t[maxIndex] || 0) : 0;
    if(els.scrubMin) els.scrubMin.textContent = "0";
    if(els.scrubMax) els.scrubMax.textContent = lastT.toFixed(0);

    const currentIdx = (State.viewIndex!=null) ? State.viewIndex : maxIndex;
    const currentT = (len && currentIdx>=0)
      ? (State.series.t[currentIdx] || 0)
      : 0;
    if(els.scrubVal) els.scrubVal.textContent = currentT.toFixed(0);
  }

  /* Chart rendering entry point */
  function drawCharts(){
    drawIncVaxChart();
    drawSIRChart();
  }

  /*
   * Incidence + prevalence + vaccination chart:
   * - Left axis: counts
   * - Right axis: % vaccinated
   */
  function drawIncVaxChart(){
    const c = els.incVaxChart;
    if (!c) return;
    const ctx = c.getContext('2d');
    const dpr = window.devicePixelRatio || 1;

    const W = (c.clientWidth || c.width / dpr);
    const H = (c.clientHeight || c.height / dpr);

    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = cssVar('--canvas-bg') || "#0e1320";
    ctx.fillRect(0,0,W,H);

    const s = State.series;
    const len = s.t.length;
    const upto = (State.viewIndex != null)
      ? Math.min(State.viewIndex, len-1)
      : len-1;

    const padL = 52;
    const padR = 42;
    const padT = 16;
    const padB = 24;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;

    ctx.fillStyle = cssVar('--muted');
    ctx.font = `${cssVar('--fz-2xs')} ${cssVar('--font-sans')}`;
    ctx.textAlign = "center";
    ctx.fillText("Time (days)", padL + plotW/2, H - 10);

    ctx.save();
    ctx.translate(14, padT + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.fillText("Count (incidence & prevalence)", 0, 0);
    ctx.restore();

    ctx.save();
    ctx.translate(W - 10, padT + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.fillText("% Vaccinated", 0, 0);
    ctx.restore();

    if(len === 0 || upto < 0 || plotW <= 0 || plotH <= 0){
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, H - padB);
      ctx.lineTo(W - padR, H - padB);
      ctx.stroke();
      return;
    }

    const maxT = s.t[upto] || 1;
    const maxInc = Math.max(0, ...s.inc.slice(0, upto+1));
    const maxPrev = Math.max(0, ...s.I.slice(0, upto+1));
    const maxLeft = Math.max(1, maxInc, maxPrev);

    const xForIndex = i =>
      padL + (s.t[i] / maxT) * plotW;

    const yForLeft = v =>
      (H - padB) - (v / maxLeft) * plotH;

    const yForPct = pct =>
      (H - padB) - (pct / 100) * plotH;

    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.fillStyle = cssVar('--muted');
    ctx.font = `${cssVar('--fz-2xs')} ${cssVar('--font-sans')}`;

    const xTicks = 5;
    ctx.textAlign = "center";
    for(let i=0;i<=xTicks;i++){
      const frac = i/xTicks;
      const tVal = frac * maxT;
      const x = padL + frac * plotW;

      ctx.beginPath();
      ctx.moveTo(x, padT);
      ctx.lineTo(x, H - padB);
      ctx.stroke();

      ctx.fillText(tVal.toFixed(0), x, H - 12);
    }

    const yTicks = 4;
    ctx.textAlign = "right";
    for(let i=0;i<=yTicks;i++){
      const frac = i/yTicks;
      const v = maxLeft * (1 - frac);
      const y = padT + frac * plotH;

      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(W - padR, y);
      ctx.stroke();

      ctx.fillText(v.toFixed(0), padL - 4, y + 3);
    }

    ctx.textAlign = "left";
    for(let i=0;i<=yTicks;i++){
      const frac = i/yTicks;
      const pct = 100 * (1 - frac);
      const y = padT + frac * plotH;
      ctx.fillText(pct.toFixed(0), W - padR + 4, y + 3);
    }

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, H - padB);
    ctx.lineTo(W - padR, H - padB);
    ctx.stroke();

    ctx.strokeStyle = cssVar('--c-exp');
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    for(let i=0;i<=upto;i++){
      const x = xForIndex(i);
      const y = yForLeft(s.inc[i] || 0);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.strokeStyle = cssVar('--accent2');
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    for(let i=0;i<=upto;i++){
      const x = xForIndex(i);
      const y = yForLeft(s.I[i] || 0);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    if(s.vAllPct && s.vAllPct.length){
      ctx.strokeStyle = cssVar('--accent');
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      for(let i=0;i<=upto;i++){
        const x = xForIndex(i);
        const y = yForPct(s.vAllPct[i] || 0);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
  }

  /*
   * SEIRD chart:
   * - Shows compartment sizes over time as proportions of N.
   */
  function drawSIRChart(){
    const c = els.sirChart;
    if (!c) return;
    const ctx = c.getContext('2d');
    const dpr = window.devicePixelRatio || 1;

    const W = (c.clientWidth || c.width / dpr);
    const H = (c.clientHeight || c.height / dpr);

    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = cssVar('--canvas-bg') || "#0e1320";
    ctx.fillRect(0,0,W,H);

    const s = State.series;
    const len = s.t.length;
    const upto = (State.viewIndex != null)
      ? Math.min(State.viewIndex, len-1)
      : len-1;

    const padL = 42, padR = 10, padT = 16, padB = 24;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;

    ctx.fillStyle = cssVar('--muted');
    ctx.font = `${cssVar('--fz-2xs')} ${cssVar('--font-sans')}`;
    ctx.textAlign = "center";
    ctx.fillText("Time (days)", padL + plotW/2, H - 10);

    ctx.save();
    ctx.translate(10, padT + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.fillText("Individuals", 0, 0);
    ctx.restore();

    if(len === 0 || upto < 0 || plotW <= 0 || plotH <= 0){
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, H - padB);
      ctx.lineTo(W - padR, H - padB);
      ctx.stroke();
      return;
    }

    const maxT = s.t[upto] || 1;
    const N = State.N || 1;

    const xForIndex = i =>
      padL + (s.t[i] / maxT) * plotW;

    const yForVal = v =>
      (H - padB) - (v / Math.max(1,N)) * plotH;

    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.fillStyle = cssVar('--muted');
    ctx.font = `${cssVar('--fz-2xs')} ${cssVar('--font-sans')}`;

    const xTicks = 5;
    ctx.textAlign = "center";
    for(let i=0;i<=xTicks;i++){
      const frac = i/xTicks;
      const tVal = frac * maxT;
      const x = padL + frac * plotW;
      ctx.beginPath();
      ctx.moveTo(x, padT);
      ctx.lineTo(x, H - padB);
      ctx.stroke();
      ctx.fillText(tVal.toFixed(0), x, H - 12);
    }

    const yTicks = 4;
    ctx.textAlign = "right";
    for(let i=0;i<=yTicks;i++){
      const frac = i/yTicks;
      const v = N * (1 - frac);
      const y = padT + frac * plotH;
      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(W - padR, y);
      ctx.stroke();
      ctx.fillText(v.toFixed(0), padL - 4, y + 3);
    }

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, H - padB);
    ctx.lineTo(W - padR, H - padB);
    ctx.stroke();

    function plot(arr, colorVar){
      if(!arr || !arr.length) return;
      ctx.strokeStyle = cssVar(colorVar);
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      for(let i=0;i<=upto;i++){
        const x = xForIndex(i);
        const y = yForVal(arr[i] || 0);
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    plot(s.S, '--c-sus');
    plot(s.E, '--c-exp');
    plot(s.I, '--c-inf');
    plot(s.R, '--c-imm');
    plot(s.D, '--c-dead');
  }

  /*
   * Event bindings:
   * - Scenarios, sliders, run/pause, scrubber, CSV export, resize.
   * - If you extend the UI, plug handlers into this section.
   */
  els.scenario.addEventListener('change', e=> applyScenario(e.target.value));

  function applyScenario(name){
    const presets = {
      rare: {
        N: 5000,
        I0: 1,
        beta: 0.12,
        gamma: 0.20,
        mu: 0.005
      },
      endemic: {
        N: 5000,
        I0: 10,
        beta: 0.18,
        gamma: 0.18,
        mu: 0.002
      },
      outbreak: {
        N: 5000,
        I0: 5,
        beta: 0.55,
        gamma: 0.10,
        mu: 0.01
      },
      flu: {
        N: 5000,
        I0: 3,
        beta: 0.32,
        gamma: 0.14,
        mu: 0.004
      },
      covid: {
        N: 5000,
        I0: 5,
        beta: 0.45,
        gamma: 0.08,
        mu: 0.006
      },
      measles: {
        N: 5000,
        I0: 3,
        beta: 1.10,
        gamma: 0.14,
        mu: 0.0005,
        vaxCov: 70,
        ve: 97
      },
      ebola: {
        N: 5000,
        I0: 2,
        beta: 0.25,
        gamma: 0.14,
        mu: 0.12,
        vaxCov: 0,
        ve: 0
      },
      sars1: {
        N: 5000,
        I0: 3,
        beta: 0.30,
        gamma: 0.14,
        mu: 0.02
      },
      mers: {
        N: 5000,
        I0: 3,
        beta: 0.14,
        gamma: 0.14,
        mu: 0.08
      },
      noro: {
        N: 5000,
        I0: 5,
        beta: 0.70,
        gamma: 0.40,
        mu: 0.0001
      }
    };

    const p = presets[name];
    if (p) {
      if (p.N      != null) els.N.value      = p.N;
      if (p.I0     != null) els.I0.value     = p.I0;
      if (p.beta   != null) els.beta.value   = p.beta;
      if (p.gamma  != null) els.gamma.value  = p.gamma;
      if (p.mu     != null) els.mu.value     = p.mu;

      if (p.gamma != null && els.daysInf) {
        const days = p.gamma > 0 ? (1 / p.gamma) : 10;
        els.daysInf.value = days.toFixed(1);
      }

      if (p.vaxCov != null && els.vaxCov) {
        els.vaxCov.value = p.vaxCov;
      }
      if (p.ve != null && els.ve) {
        els.ve.value = p.ve;
      }
    }

    syncSliders();
    initPeople();
  }

  [
    els.N, els.I0, els.R0, els.dt,
    els.stoch, els.seed,
    els.autoStop, els.contacts,
    els.daysInf
  ].forEach(input=>{
    if(!input) return;
    input.addEventListener('change', ()=>{
      if(input === els.seed){
        setSeed(+els.seed.value || 42);
      }
      initPeople();
    });
  });

  if(els.N){
    els.N.addEventListener('input', ()=>{
      if(els.NVal){
        els.NVal.textContent = els.N.value;
      }
      initPeople();
    });
  }

  ['beta','gamma','mu'].forEach(id=>{
    const el = els[id];
    if(!el) return;
    el.addEventListener('input', ()=>{
      syncSliders();
      branchFromCurrent({reassignVaccination:false});
    });
  });

  ['ve','vaxCov'].forEach(id=>{
    const el = els[id];
    if(!el) return;
    el.addEventListener('input', ()=>{
      syncSliders();
      branchFromCurrent({reassignVaccination:true});
    });
  });

  ['vaxRate','mutRate'].forEach(id=>{
    const el = els[id];
    if(!el) return;
    el.addEventListener('input', ()=>{
      syncSliders();
      branchFromCurrent({reassignVaccination:false});
    });
  });

  els.toggle.addEventListener('click', ()=>{
    if(State.running){
      resetToggleToStopped();
    }else{
      if(State.viewIndex != null){
        branchFromCurrent({reassignVaccination:false});
      }
      setToggleRunning();
      loop();
    }
  });

  els.reset.addEventListener('click', ()=>{
    setSeed(+els.seed.value || 42);
    els.vaxCov.value = 0;
    syncSliders();
    initPeople();
  });

  els.scrubber.addEventListener('input', ()=>{
    const vIndex = parseInt(els.scrubber.value,10)||0;
    State.viewIndex = vIndex;
    const tVal = State.series.t[vIndex] ?? 0;

    els.viewLabel.textContent = State.series.t.length
      ? `t=${(tVal||0).toFixed(0)} days`
      : 'Live';

    if(els.scrubVal) els.scrubVal.textContent = (tVal||0).toFixed(0);

    if(State.series.t.length && els.scrubMax){
      const last = State.series.t[State.series.t.length-1] || 0;
      els.scrubMax.textContent = last.toFixed(0);
    }

    drawCanvas();
    updateSidebarCounts();
    drawCharts();
    updateRDisplaysLive();
    updateMetrics();
  });

  /* CSV export: exports minimal series for downstream analysis */
  els.exportCSV.addEventListener('click', ()=>{
    const rows=[["t","S","E","I","R","D","everInf"]];
    const s=State.series;
    for(let i=0;i<s.t.length;i++){
      rows.push([
        s.t[i],
        s.S[i],
        s.E[i],
        s.I[i],
        s.R[i],
        s.D[i],
        (s.everInf && s.everInf[i] != null) ? s.everInf[i] : ""
      ]);
    }
    const csv = rows.map(r=>r.join(',')).join('\n');
    const blob = new Blob([csv],{type:'text/csv'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='simulation_timeseries.csv';
    a.click();
  });

  /* Main animation loop: runs only while State.running is true */
  function loop(){
    if(!State.running) return;
    step();
    requestAnimationFrame(loop);
  }

  /* Keep layout and charts responsive */
  window.addEventListener('resize', () => {
    resizeSimCanvas();
    updateChartLayouts();
    drawCanvas();
    drawCharts();
    updateSidebarCounts();
    updateRDisplaysLive();
    updateMetrics();
  });

  /* Initial boot sequence:
   * 1) Sync UI labels
   * 2) Seed RNG
   * 3) Build initial population
   * 4) Size charts and draw one frame
   */
  syncSliders();
  setSeed(+els.seed.value || 42);
  initPeople();
  updateChartLayouts();
  drawCharts();

})();
</script>
</body>
</html>
